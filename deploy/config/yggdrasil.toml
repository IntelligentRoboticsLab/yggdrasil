[filter.button]
# The threshold for a button to be considered pressed.
activation_threshold = 0.5
# The time (in ms) a button needs to be held down, in order to be considered held down.
held_duration_threshold = 500

[filter.fsr]
# Threshold for ground contact detection using average FSR sensor values from both feet.
ground_contact_threshold = 0.12
# Timeout for changing the value of the ground contact state, in milliseconds.
ground_contact_timeout = 20
# Maximum amount of pressure measured by a single sensor.
max_pressure = 5.0
# Initial value for minimum pressure measured by a single sensor.
min_pressure = 0.3
# The time to sample pressure values before updating the maximum value for each sensor, in milliseconds.
highest_pressure_update_rate = 10000
# The number of foot switches required before updating the minimum value for each sensor.
num_foot_switches = 10

[primary_state]
# Time duration between chest blinks in ms.
chest_blink_interval = 1000

[game_controller]
# Delay (in ms) between the status updates the robot sends to the game-controller.
game_controller_return_delay = 500
# The maximum time (in ms) allowed between game-controller messages.
# If the robot doesn't receive a game-controller message for this amount of time,
# it will consider the connection to the game-controller as "lost".
game_controller_timeout = 5000

[camera.top]
# The path to the camera device.
path = "/dev/video-top"
# The requested width of the image.
width = 640
# The requested height of the image.
height = 480
# This variable specifies how many images from the top camera can be alive at the same time.
# It is recommended to have at least one more buffer than is required. This way, the next frame
# from the camera can already be stored in a buffer, reducing the latency between destructing a
# `TopImage` and being able to fetch the newest `TopImage`.
num_buffers = 5
# Whether the image should be flipped horizontally.
flip_horizontally = true
# Whether the image should be flipped vertically.
flip_vertically = true
# Whether the image focus automatically
focus_auto = false
# Whether to turn on auto exposure
exposure_auto = true
# Temperature value for white balancing
white_balance_temperature = 2500
# Whether to turn on auto white balancing
white_balance_temperature_auto = true

[camera.top.calibration]
# The extrinsic rotation for the camera in degrees, xyz euler angles.
extrinsic_rotation = [0.04, -3.001, 1.3]
# The focal length for the camera in pixels.
focal_lengths = [608, 609]
# The optical center of the camera sensor in pixels.
cc_optical_center = [320, 240]

[camera.bottom]
# The path to the camera device.
path = "/dev/video-bottom"
# The requested width of the image.
width = 320
# The requested height of the image.
height = 240
# This variable specifies how many images from the bottom camera can be alive at the same time.
# It is recommended to have at least one more buffer than is required. This way, the next frame
# from the camera can already be stored in a buffer, reducing the latency between destructing a
# `BottomImage` and being able to fetch the newest `BottomImage`.
num_buffers = 5
# Whether the image should be flipped horizontally.
flip_horizontally = false
# Whether the image should be flipped vertically.
flip_vertically = false
# Whether the image focus automatically
focus_auto = false
# Whether to turn on auto exposure
exposure_auto = true
# Temperature value for white balancing
white_balance_temperature = 2500
# Whether to turn on auto white balancing
white_balance_temperature_auto = true

[camera.bottom.calibration]
# The extrinsic rotation for the camera in degrees, euler angles.
extrinsic_rotation = [0, 0, 0]
# The focal length for the camera in pixels.
focal_lengths = [570, 570]
# The optical center of the camera sensor in pixels
cc_optical_center = [320, 240]


[vision.field_marks]
# The distance after which field marks are considered to be too far away to be detected, in meters.
distance_threshold = 15.0
# The tolerance for the angle between two lines being close to 90 degrees, in degrees.
angle_tolerance = 10
# The confidence threshold for the softmax score predicted by the classification model
confidence_threshold = 0.7
# The size of a patch at 1.0 meters distance in pixels.
# This value is divided by the distance to get the size of the patch at that distance, and the patch is then
# resized to 32x32 pixels before being fed into the neural network.
patch_scale = 140
# The maximum amount of time (in micro seconds) we can spend on classifying field mark proposals.
# If this time is exceeded, we will skip the classification of the remaining proposals.
time_budget = 3000


# The configuration for the vqf-based orientation filter.
# See this paper https://arxiv.org/pdf/2203.17024 for more.
[orientation]
# Time constant $\tau_{acc}$ for accelerometer low-pass filtering.
#
# Small values for $\tau_{acc}$ imply trust on the accelerometer
# measurements, while large values of $\tau_{acc}$ imply trust on the
# gyroscope measurements.
#
# The time constant $\tau_{acc}$ corresponds to the cutoff frequency $f_c$
# of the second-order Butterworth low-pass filter as follows: $$f_c =
# \frac{\sqrt(2)}{2 \pi \tau_{acc}}$$
tau_accelerometer = 1000

# Enable gyroscope bias estimation during motion phases
# Gyroscope bias is estimated based on the inclination correction only!
do_bias_estimation = true

# Enables gyroscope bias estimation during rest phases.
# This enables "rest"-phase detection, phases in which the IMU is at rest.
# During rest-phases, the gyroscope bias is estimated from the
# low-pass filtered gyroscope readings.
do_rest_bias_estimation = true

# Standard deviation of the initial bias estimation uncertainty, in
# degrees per second.
bias_sigma_initial = 0.5

# Time in which the bias estimation uncertainty increases from 0 degrees to
# 0.1 degrees. This value determines the system noise assumed by the
# Kalman filter.
bias_forgetting_time = 100

# Maximum expected gyroscope bias, in degrees per second.
bias_clip = 2.0

# Standard deviation of the converged bias estimation uncertainty during
# motion, in degrees per second.
bias_sigma_motion = 0.1

# Forgetting factor for unobservable bias in vertical direction during
# motion.
#
# This value is the relative weight of an artificial zero measurement that
# ensures that the bias estimate in the unobservable direction will
# eventually decay to zero.
bias_vertical_forgetting_factor = 0.0001

# Standard deviation of the converged bias estimation uncertainty during a
# rest phase, in degrees per second.
bias_sigma_rest = 0.03

# Time threshold in milliseconds for rest detection.
#
# A rest phase is detected when the measurements have been close to the
# low-pass filtered reference for at least this duration.
rest_min_duration = 1500

# Time constant in milliseconds for the low-pass filter used in the rest detection.
#
# This time constant characterizes a second-order Butterworth low-pass
# filter used to obtain the reference for rest detection.
rest_filter_tau = 500

# Angular velocity threshold for rest detection, in degrees per second.
#
# For a rest phase to be detected, the norm of the deviation between
# measurement and reference must be below the provided threshold.
# The absolute value of each component must also be below `bias_clip`
rest_threshold_gyro = 2.0

# Acceleration threshold for rest phase detection in m/s^2.
#
# For a rest phase to be detected, the norm of the deviation between
# measurement and reference must be below the provided threshold.
rest_threshold_accel = 0.5
