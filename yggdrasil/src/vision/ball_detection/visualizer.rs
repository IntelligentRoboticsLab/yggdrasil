//! See [`BallDetectionVisualizerPlugin`].

use crate::core::debug::DebugContext;
use bevy::prelude::*;
use heimdall::CameraLocation;
use rerun::AnnotationInfo;
use std::marker::PhantomData;

use super::{classifier::Balls, proposal::BallProposals};

pub(super) const PROPOSAL_CLASS_ID: u16 = 1;
pub(super) const CLASSIFIED_CLASS_ID: u16 = 2;

/// Plugin for visualizing ball detections in rerun.
///
/// Visualizations are split in two components:
/// - Ball proposals, which are the proposals generated by [`BallProposalPlugin`].
/// - Ball classifications, which are the proposals that were classified as ball by the [`BallClassifierPlugin`].
///
/// [`BallProposalPlugin`]: `super::proposal::BallProposalPlugin`
/// [`BallClassifierPlugin`]: `super::classifier::BallClassifierPlugin`
#[derive(Debug, Clone, Default)]
pub(super) struct BallDetectionVisualizerPlugin<T: CameraLocation>(PhantomData<T>);

impl<T: CameraLocation> Plugin for BallDetectionVisualizerPlugin<T> {
    fn build(&self, app: &mut App) {
        app.add_systems(PostStartup, setup_ball_debug_logging::<T>)
            .add_systems(
                PostUpdate,
                (
                    log_ball_proposals::<T>.run_if(resource_exists_and_changed::<BallProposals<T>>),
                    log_ball_classifications::<T>.run_if(resource_exists_and_changed::<Balls>),
                ),
            );
    }
}

/// System that sets up the [`AnnotationContext`] for the ball detection debug logging.
fn setup_ball_debug_logging<T: CameraLocation>(dbg: DebugContext) {
    dbg.log_static(
        T::make_entity_path("balls"),
        &rerun::AnnotationContext::new([
            AnnotationInfo {
                id: PROPOSAL_CLASS_ID,
                label: None,
                color: Some(rerun::Rgba32::from_rgb(190, 190, 190)),
            },
            AnnotationInfo {
                id: CLASSIFIED_CLASS_ID,
                label: None,
                color: Some(rerun::Rgba32::from_rgb(128, 0, 128)),
            },
        ]),
    );
}

fn log_ball_proposals<T: CameraLocation>(dbg: DebugContext, proposals: Res<BallProposals<T>>) {
    let (positions, half_sizes): (Vec<_>, Vec<_>) = proposals
        .proposals
        .iter()
        .map(|proposal| {
            (
                (proposal.position.x as f32, proposal.position.y as f32),
                (proposal.scale, proposal.scale),
            )
        })
        .unzip();

    dbg.log_with_cycle(
        T::make_entity_path("balls/proposals"),
        proposals.image.cycle(),
        &rerun::Boxes2D::from_centers_and_half_sizes(&positions, &half_sizes)
            .with_class_ids(vec![PROPOSAL_CLASS_ID; proposals.proposals.len()]),
    );
}

fn log_ball_classifications<T: CameraLocation>(dbg: DebugContext, balls: Res<Balls>) {
    let (positions, (half_sizes, confidences)): (Vec<_>, (Vec<_>, Vec<_>)) = balls
        .balls
        .iter()
        // TODO: Once we have a better unified way to store the balls for different camera positions, we can
        // drop the extra condition here.
        .filter(|ball| ball.is_fresh && ball.camera == T::POSITION)
        .map(|ball| {
            (
                (ball.position_image.x, ball.position_image.y),
                (
                    (ball.scale / 2.0, ball.scale / 2.0),
                    format!("{:.2}", ball.confidence),
                ),
            )
        })
        .unzip();

    let most_recent_cycle = match T::POSITION {
        heimdall::CameraPosition::Top => balls.top_image.cycle(),
        heimdall::CameraPosition::Bottom => balls.bottom_image.cycle(),
    };

    dbg.log_with_cycle(
        T::make_entity_path("balls/classifications"),
        most_recent_cycle,
        &rerun::Boxes2D::from_centers_and_half_sizes(&positions, &half_sizes)
            .with_class_ids(vec![CLASSIFIED_CLASS_ID; balls.balls.len()])
            .with_labels(confidences),
    );
}
